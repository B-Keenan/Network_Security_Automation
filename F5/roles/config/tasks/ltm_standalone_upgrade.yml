# Upgrade will be performed on a single host.
# Not for DNS or vCMP configurations.
# WIP
#
# Custom variables: additional_arguments (AWX Survey textarea)
# image: BIGIP-17.1.2.2-0.0.12.iso
---
#- name: Perform pre-upgrade shell tasks
  #ansible.builtin.include_tasks: pre_upgrade_shell.yml
- name: Gather Date
  f5networks.f5_modules.bigip_command:
    commands:
      - run util bash -c 'date "+%F"'
    provider: "{{ provider }}"
  register: date

- name: Get current icrd.timeout value
  f5networks.f5_modules.bigip_sys_db:
    key: icrd.timeout
    provider: "{{ provider }}"
  register: icrd_timeout_result

- name: Set icrd.timeout to 180 if less than 180
  f5networks.f5_modules.bigip_sys_db:
    key: icrd.timeout
    value: "180"
    provider: "{{ provider }}"
  when: icrd_timeout_result.value | int < 180
  register: icrd_timeout_change

- name: Get current restjavad.timeout value
  f5networks.f5_modules.bigip_sys_db:
    key: restjavad.timeout
    provider: "{{ provider }}"
  register: restjavad_timeout_result

- name: Set restjavad.timeout to 180 if less than 180
  f5networks.f5_modules.bigip_sys_db:
    key: restjavad.timeout
    value: "180"
    provider: "{{ provider }}"
  when: restjavad_timeout_result.value | int < 180
  register: restjavad_timeout_change

- name: Get current restnoded.timeout value
  f5networks.f5_modules.bigip_sys_db:
    key: restnoded.timeout
    provider: "{{ provider }}"
  register: restnoded_timeout_result

- name: Set restnoded.timeout to 180 if less than 180
  f5networks.f5_modules.bigip_sys_db:
    key: restnoded.timeout
    value: "180"
    provider: "{{ provider }}"
  when: restnoded_timeout_result.value | int < 180
  register: restnoded_timeout_change

- name: Set changed flag for any timeout modifications
  set_fact:
    timeout_changed: "{{ icrd_timeout_change.changed or restjavad_timeout_change.changed or restnoded_timeout_change.changed }}"

- name: Save running configuration
  f5networks.f5_modules.bigip_config:
    save: yes
    provider: "{{ provider }}"

- name: Restart restjavad and restnoded services
  f5networks.f5_modules.bigip_command:
    commands: restart sys service restjavad restnoded
    provider: "{{ provider }}"
  when: timeout_changed | bool

- name: Wait for services to start
  wait_for:
    timeout: 30
  when: timeout_changed | bool

- name: Gather subsets in Common
  f5networks.f5_modules.bigip_device_info:
    gather_subset:
      - license
      - partitions
      - software-volumes
    provider: "{{ provider }}"
  register: device_info

- name: Gather subsets in all partitions
  f5networks.f5_modules.bigip_device_info:
    partition: "{{ item }}"
    gather_subset:
      - virtual-servers
      - ltm-pools
    provider: "{{ provider }}"
  loop: "{{ device_info.partitions | json_query('[*].name') }}"
  register: partition_info

- name: Pre-upgrade parse
  set_fact:
    start_stats:
      virtual_servers: "{{ partition_info.results | map(attribute='virtual_servers') | flatten
        | items2dict(key_name='full_path', value_name='availability_status') }}"
      ltm_pools: "{{ partition_info.results | map(attribute='ltm_pools') | flatten
        | items2dict(key_name='full_path', value_name='availability_status') }}"

- name: Set list of existing volumes
  set_fact:
    existing_volumes: >-
      {{ device_info.software_volumes | map(attribute='name') | list }}

- name: Set first available inactive volume
  set_fact:
    inactive_volume: >-
      {{ (device_info.software_volumes
            | selectattr('active', 'equalto', False)
            | map(attribute='name')
            | list)[0] | default(None) }}

- name: Determine most common prefix for volume names
  set_fact:
    most_common_prefix: >-
      {{ (existing_volumes
            | map('regex_search', '^(HD|MD)')
            | list
            | unique)[0] if (existing_volumes | length > 0) }}
  when: inactive_volume is none

- name: Determine next available volume number
  set_fact:
    next_volume_number: >-
      {{ (existing_volumes
            | select('match', '^(HD|MD)1\\.\\d+$')
            | map('regex_replace', '^(HD|MD)1\\.', '')
            | map('int')
            | max + 1) if (existing_volumes | length > 0) else 1 }}
  when: inactive_volume is none

- name: Set target volume
  set_fact:
    target_volume: >-
      {{ inactive_volume if inactive_volume is not none
        else most_common_prefix + '1.' + next_volume_number | string }}

- name: Reactivate license
  f5networks.f5_modules.bigip_device_license:
    license_key: "{{ device_info.registration_key }}"
    provider: "{{ provider }}"

#- name: Wait for device to return to Active
  #ansible.builtin.wait_for:
    #path: /var/prompt/ps1
    #search_regex: Active
  #delegate_to: "{{ inventory_hostname }}"

#- name: Pre-upgrade UCS
  #ansible.builtin.include_tasks: create_ucs.yml

#- name: Upload upgrade image to device
  #ansible.posix.synchronize:
    #src: "benk@10.255.32.210:/var/tmp/{{ upgrade_iso }}"
    #dest: "/shared/images/"
  #delegate_to: "{{ inventory_hostname }}"

#- name: Wait for image to become available
  #wait_for:
    #timeout: 30

- name: Install BIG-IP software
  f5networks.f5_modules.bigip_software_install:
    image: "{{ additional_arguments.image }}"
    state: activated
    volume: "{{ target_volume.stdout }}"
    provider: "{{ provider }}"

#- name: Wait for device to return to Active
  #wait_for:
    #path: /var/prompt/ps1
    #search_regex: Active
  #delegate_to: "{{ inventory_hostname }}"
- name: Allow some time for services to start
  ansible.builtin.pause:
    seconds: 600

- block:
  - name: Gather post-upgrade config facts
    f5networks.f5_modules.bigip_device_info:
      partition: "{{ item }}"
      gather_subset:
        - virtual-servers
        - ltm-pools
      provider: "{{ provider }}"
    loop: "{{ device_info.partitions | json_query('[*].name') }}"
    register: partition_info

  - name: Post-upgrade parse
    set_fact:
      end_stats:
        virtual_servers: "{{ partition_info.results | map(attribute='virtual_servers') | flatten
          | items2dict(key_name='full_path', value_name='availability_status') }}"
        ltm_pools: "{{ partition_info.results | map(attribute='ltm_pools') | flatten
          | items2dict(key_name='full_path', value_name='availability_status') }}"

  - name: Check Virtual Servers
    assert:
      that:
        - item.value == end_stats.virtual_servers[item.key]
      fail_msg: "Virtual server '{{ item.key }}' state changed from '{{ item.value }}' to '{{ end_stats.virtual_servers[item.key] }}'"
      success_msg: "{{ item.key }} state unchanged"
      quiet: yes
    loop: "{{ start_stats.virtual_servers | dict2items }}"
    loop_control:
      label: "{{ item.key }}"

  - name: Check Pools
    assert:
      that:
        - item.value == end_stats.ltm_pools[item.key]
      fail_msg: "Pool '{{ item.key }}' state changed from '{{ item.value }}' to '{{ end_stats.ltm_pools[item.key] }}'"
      success_msg: "{{ item.key }} state unchanged"
      quiet: yes
    loop: "{{ start_stats.ltm_pools | dict2items }}"
    loop_control:
      label: "{{ item.key }}"
    
#- name: Post-upgrade UCS
  #ansible.builtin.include_tasks: create_ucs.yml